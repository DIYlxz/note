#  动态规划

**原理：** 动态规划是利用历史记录来避免重复计算。这些历史记录需要用一些变量来保存，一般是一维数组或者二维数组

1. 定义数组元素的含义
2. 找出数组元素之间的关系式
3. 找出初始值



##  例题1：斐波那契数列

 [斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

```javascript
var fib = function(n) {
    const arr = [0,1];
    for(let i=2; i<=n; i++) {
        arr[i] = arr[i-1] + arr[i-2];
    }
    return arr[n];
};
```

做题步骤：

1. arr[i]含义为：第i个数的和
2. 求arr[n],又是因为arr[n]为前两项数之和，那么 arr[n] = arr[n-1] + arr[n-2]
3. 当n=1时，下标出现负数。所以arr[n] (n<=1)时得直接给出它得值。



##  例题2：不同路径

[不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

![不同路径](C:\Users\Administrator\Desktop\note\不同路径.png)



解题步骤：

1. dp\[i\][j]含义为：当机器人从左上角走到[i,j]位置时，一共有dp\[i][j]种路径

2. 到达\[i][j]的情况

   1. 从\[i-1][j]一步到达
   2. 从\[i][j-1]一步到达

   所以关系式为 dp\[i][j] = dp\[i-1][j] + dp\[i][j-1]

3. 当i为0或j为0时，不能使用关系式子（下标为负）

​	当i为0时，机器人只能往下走dp\[0][j] = 1;

​	当j为0时，机器人只能往右走dp\[i][0] = 1;

```javascript
var uniquePaths = function(m, n) {
    const dp = Array(m).fill().map(()=>Array(n).fill(0));
    for(let j=0; j<n; j++) {
        dp[0][j] = 1;
    }
    for(let i=0; i<m; i++) {
        dp[i][0] = 1;
    }
    for(let i=1; i<m; i++) {
        for(let j=1; j<n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
};
```



###  优化

由关系式得出dp\[i][j] = dp\[i-1][j] + dp\[i][j-1]，当前值只需要知道上一行的数据就可以了，其他行用不上

所以只需要一维数组保存即可，优化了空间

1. 含义：dp数组保存上一行数值
2. 关系式：dp[i] = dp[i] + dp[i-1];
3. 边界：

​	i=0：dp[i] = 1;

```javascript
var uniquePaths = function(m, n) {
    const dp = [];
    //初始化第一行
    for(let i=0; i<n; i++) {
        dp[i] = 1;
    }
    //从第二行开始
    for(let i=1; i<m; i++) {
        //第一列始终为1
        dp[0] = 1;
        for(let j=1; j<n; j++) {
            dp[j] = dp[j] + dp[j-1];
        }
    }
    return dp[n-1];
};
```







##  例题3：最小路径和

[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

![最小路径和](C:\Users\Administrator\Desktop\note\img\最小路径和.png)



解题步骤：

1. dp\[i][j]的含义： 在\[i][j]位置上最小数字总和
2. 关系式：dp\[i][j] = Math.min(dp\[i-1][j], dp\[i][j-1]) + grid\[i][j];
3. 边界：

​	当i=0时，只能往右走

​	dp\[0][j] = dp\[0][j-1] + grid\[0][j];

​	当j=0时，只能往右走

​	dp\[i][0] = dp\[i-1][0] + grid\[i][0];

```javascript
var minPathSum = function(grid) {
    let m = grid.length;
    let n = grid[0].length;
    const dp = Array(m).fill().map(item=>Array(n).fill(0));
    dp[0][0] = grid[0][0];
    for(let j=1; j<n; j++) {
        dp[0][j] = dp[0][j-1] + grid[0][j];
    }
    for(let i=1; i<m; i++) {
        dp[i][0] = dp[i-1][0] + grid[i][0];
    }
    for(let i=1; i<m; i++) {
        for(let j=1; j<n; j++) {
            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
        }
    }
    return dp[m-1][n-1];
};
```



##  例题4：编辑距离

[编辑距离](https://leetcode-cn.com/problems/edit-distance/)

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符



解题步骤：

1. 含义：当字符串word1长度为i时，word2的长度为j时，那么dp\[i][j]为长度为i的字符串变换到长度为j的字符串的最少操作次数。

​	例子：word1 = "horse" , word2 = “ros" 当i为1时，j为2时，那么dp\[1][2]就是”h"变换到“ro”的最少操作次数

2. 关系式

​	当至少有一个字符串为空串时：那么最少操作数为另一个字符串的长度

​	当没有字符串为空时

​		1. (插入)如果“hors”到"ros"为X步，那么"horse"到"ros"为X+1步。

​    	2. (删除)如果"horse"到"ro"为Y步(因为在当前字符串删除等价于另一个字符串插入)，那么"horse"到"ros"为Y+1步。

​		3. (替换)如果"hors"到"ros"为Z步，那么"horse"到"ros"为Z+1步

​	即：

​	当最后一个字符相同时：dp\[i][j] = min(dp\[i-1][j] + 1, dp\[i][j-1] + 1, dp\[i-1][j-1])

​	当最后一个字符不相同时：dp\[i][j] = min(dp\[i-1][j] + 1, dp\[i][j-1] + 1, dp\[i-1][j-1] + 1)

3. 边界

​	i=0：dp\[0][j] = j;

​	j=0：dp\[i][0] = i;

​	i=0, j=0: dp\[0][0] = 0;

```javascript
var minDistance = function (word1, word2) {
    let m = word1.length + 1;
    let n = word2.length + 1;
    const dp = Array(m).fill().map(() => Array(n).fill(0));
    for (let i = 1; i < m; i++) {
        dp[i][0] = i;
    }
    for (let j = 1; j < n; j++) {
        dp[0][j] = j;
    }
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if(word1[i-1] == word2[j-1]) {
                dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1]);
            }else {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
            }
        }
    }
    return dp[m - 1][n - 1];
};
```



